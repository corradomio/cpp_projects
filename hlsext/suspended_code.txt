/*
 * File:   main.cpp
 * Author: Corrado Mio
 *
 * Created on May 2, 2015, 2:45 PM
 */
#include "syntax.hpp"

#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <functional>
#include "trycatch.hpp"
#include "closure.hpp"
#include "float4.hpp"
#include "refcount.hpp"
#include "malloc.h"
#include "allocate.h"


#include <castor/castor.h>

using namespace castor;
using namespace std;

relation child(lref<string> c, lref<string> p) {
    return eq(c, "Sam")    && eq(p, "Mary")
        || eq(c, "Denise") && eq(p, "Mary")
        || eq(c, "Sam")    && eq(p, "Frank")
        || eq(c, "Denise") && eq(p, "Frank")
        || eq(c, "Frank")  && eq(p, "Gary");
}

relation gender(lref<string> p, lref<string> g) {
    return eq (p, "Frank") && eq(g, "male")
        || eq (p, "Sam") && eq(g, "male")
        || eq (p, "Mary") && eq(g, "female")
        || eq (p, "Denise") && eq(g, "female");
}


relation father(lref<string> f, lref<string> c) {
    return gender(f, "male") && child(c, f);
}


int main() {

    lref<string> p, g;
    relation anyPersonGender = gender(p, g);
    while(anyPersonGender()) {
        cout << *p << ": " << *g << endl;
    }
    return 0;
}





























using namespace std;
using namespace hls;


struct C {

    void m(int i, int j) {
        printf("C::m(i,j)\n");
        return;
    }

    virtual int v(int i, int j) {
        printf("C::v(i,j)=+\n");
        return i + j;
    }
};


struct D: public C {

    virtual int v(int i, int j) override {
        printf("D::v(i,j)=*\n");
        return i * j;
    }
};


int fun(int i, int j) {
    printf("fun(i,j)=*\n");
    return i*i + j*j;
}


int main_2(int argc, char** argv)
{
    C c;
    D d;

    std::function<int(int,int)> ff = fun;

    auto cm = hls::closureof(&c, &C::v);
    printf("%d\n", cm(2,3));

    auto dm = hls::closureof(&d, &C::v);
    printf("%d\n", dm(2,3));

    auto cf = hls::closureof(fun);
    printf("%d\n", cf(2,3));

    return 0;
}



int main_1(int argc, char **argv)
{
    _try
    {
        float4 x(1,0,0);
        float4 t(2,1,0);
        float4x4 m;

        float d = t.dot(x);
        float4 r = t.proj(x);

        std::cout << (f4::origin + 3*f4::x_axis + 2*f4::y_axis).unit().str() << std::endl;

        _try
        {
            _throw(exception_t("ciccio"));
        }
        _finally { }
        _finally_end
    }
    _catch(exception_t& e)
    {
        e.printstack();
    }
    _catch_all
    {
        std::cout << "catched generic exception" << std::endl;
    }
    _catch_end

    return 0;
}
